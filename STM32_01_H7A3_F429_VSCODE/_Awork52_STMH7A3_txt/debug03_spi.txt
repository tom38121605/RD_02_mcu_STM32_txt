 
=================================================spi初始化====================================== 


 flow： (spi初始化)

             BoardInit -- MX_SPI3_Init -- HAL_SPI_Init --  HAL_SPI_MspInit  --  HAL_DMA_Init   -- __HAL_LINKDMA --  ?   ( IRQ)
 

--------------------------------------------------------------------

main

     BoardInit();
           MX_SPI3_Init();
 

------

 MX_SPI3_Init( )

        hspi3.Instance = SPI3;
        hspi3.Init.Mode = SPI_MODE_MASTER;
        hspi3.Init.Direction = SPI_DIRECTION_2LINES;
        hspi3.Init.DataSize = SPI_DATASIZE_8BIT;
        hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
        hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
        hspi3.Init.NSS = SPI_NSS_SOFT;
        hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_64;
        hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
        hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
        hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
        hspi3.Init.CRCPolynomial = 0x0;
        hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
        hspi3.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
        hspi3.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
        hspi3.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
        hspi3.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
        hspi3.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
        hspi3.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
        hspi3.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
        hspi3.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;
        hspi3.Init.IOSwap = SPI_IO_SWAP_DISABLE;

        HAL_SPI_Init(&hspi3)        ;
 
 
-----------

#define SPI_LOWEND_FIFO_SIZE                          8UL
#define SPI_HIGHEND_FIFO_SIZE                         16UL

参数： hspi3
 HAL_SPI_Init(  *hspi)
 
        uint32_t crc_length;
        uint32_t packet_length; 
 
        hspi3->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; 

        /* Verify that the SPI instance supports requested data packing */
        packet_length = SPI_GetPacketSize(hspi);  //=8

        kk1= ((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > 8));      //不满足12
        kk2=  ((IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > 16));     //不满足2
        if (kk1  ||   kk2)       //不满足，忽略跳过
                return HAL_ERROR;
        
        if (hspi->State == HAL_SPI_STATE_RESET)

                hspi->Lock = HAL_UNLOCKED;
 
                /* Init the low level hardware : GPIO, CLOCK, NVIC... */
                HAL_SPI_MspInit(hspi);                                                                    //这里

        hspi->State = HAL_SPI_STATE_BUSY;

        __HAL_SPI_DISABLE(hspi3);

        crc_length = hspi->Instance->CFG1 & SPI_CFG1_CRCSIZE;    //SPI_CFG1_CRCSIZE=1<<16
 

        /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
        /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
        Communication speed, First bit, CRC calculation state, CRC Length */

        /* SPIx NSS Software Management Configuration */
        if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&        \
                        (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \
                 ((hspi->Init.Mode == SPI_MODE_SLAVE) && \
                        (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_HIGH))))
      
                SET_BIT(hspi->Instance->CR1, SPI_CR1_SSI);
       

        /* SPIx CFG1 Configuration */
        WRITE_REG(hspi->Instance->CFG1, (hspi->Init.BaudRatePrescaler | hspi->Init.CRCCalculation | crc_length |
                       hspi->Init.FifoThreshold                 | hspi->Init.DataSize));

        /* SPIx CFG2 Configuration */
        WRITE_REG(hspi->Instance->CFG2, (hspi->Init.NSSPMode                          | hspi->Init.TIMode                |
                       hspi->Init.NSSPolarity           | hspi->Init.NSS                         |
                       hspi->Init.CLKPolarity           | hspi->Init.CLKPhase        |
                       hspi->Init.FirstBit                          | hspi->Init.Mode                        |
                       hspi->Init.MasterInterDataIdleness | hspi->Init.Direction |
                       hspi->Init.MasterSSIdleness                                | hspi->Init.IOSwap));

 
        /* Insure that Underrun configuration is managed only by Salve */
        if (hspi->Init.Mode == SPI_MODE_SLAVE)
      
                /* Set Default Underrun configuration */
 
                MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRDET, SPI_CFG1_UDRDET_0);
           
                MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRCFG, SPI_CFG1_UDRCFG_1);
       
 
        /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
        CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 

        /* Insure that AFCNTR is managed only by Master */
        if ((hspi->Init.Mode & SPI_MODE_MASTER) == SPI_MODE_MASTER)
        {
                /* Alternate function GPIOs control */
                MODIFY_REG(hspi->Instance->CFG2, SPI_CFG2_AFCNTR, (hspi->Init.MasterKeepIOState));
        }

        hspi->ErrorCode        =  HAL_SPI_ERROR_NONE;
        hspi->State                 =  HAL_SPI_STATE_READY;


------

参数： hspi3
 HAL_SPI_MspInit( * hspi)
 
        GPIO_InitTypeDef GPIO_InitStruct = {0};

        if(hspi->Instance==SPI3)
         
                __HAL_RCC_SPI3_CLK_ENABLE();

                GPIO_InitStruct.Pin = DW_SCK_Pin;                                                  //GPIO_PIN_10      (SCK PC10)
                GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
                GPIO_InitStruct.Pull = GPIO_PULLDOWN;
                GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
                GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
                HAL_GPIO_Init(DW_SCK_GPIO_Port, &GPIO_InitStruct);            //GPIOC

                GPIO_InitStruct.Pin = DW_MISO_Pin;                                              //GPIO_PIN_10      (MI PC11)
                GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
                GPIO_InitStruct.Pull = GPIO_PULLDOWN;
                GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
                GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
                HAL_GPIO_Init(DW_MISO_GPIO_Port, &GPIO_InitStruct);

                GPIO_InitStruct.Pin = DW_MOSI_Pin;                                                //GPIO_PIN_12      (MO PC12)
                GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
                GPIO_InitStruct.Pull = GPIO_PULLDOWN;
                GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
                GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
                HAL_GPIO_Init(DW_MOSI_GPIO_Port, &GPIO_InitStruct);

 
                /* SPI3 DMA Init */
                /* SPI3_RX Init */
                hdma_spi3_rx.Instance = DMA2_Stream2;                                //DMA2_Stream2
                hdma_spi3_rx.Init.Request = DMA_REQUEST_SPI3_RX;           //或CCR,REQUEST_SPI3_RX
                hdma_spi3_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;    // DMA_SxCR, 数据传输方向 PERIPH_TO_MEMORY
                hdma_spi3_rx.Init.PeriphInc = DMA_PINC_DISABLE;                 // DMA_SxCR, 外设为固定地址
                hdma_spi3_rx.Init.MemInc = DMA_MINC_ENABLE;                                    // DMA_SxCR, memory 为地址跟随增加
                hdma_spi3_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;      // DMA_SxCR, PBURST=0，外设 传输增量为0
                hdma_spi3_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;        // DMA_SxCR, MBURST=0，memory 传输增量为0
                hdma_spi3_rx.Init.Mode = DMA_NORMAL;                                                   // DMA_SxCR, 0, 非圆形模式
                hdma_spi3_rx.Init.Priority = DMA_PRIORITY_HIGH;                                        // DMA_SxCR, 优先级为低
                hdma_spi3_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;                            //DMA_SxFCR, DMDIS=0, 或直接模式（全速FIFO）
 

                HAL_DMA_Init(&hdma_spi3_rx);

                //__HAL_LINKDMA(hspi3, hdmarx, hdma_spi3_rx);
                               hspi3->hdmarx = &hdma_spi3_rx;  
                               hdma_spi3_rx.Parent =  hspi3;       
 

                /* SPI3_TX Init */
                hdma_spi3_tx.Instance = DMA2_Stream3;
                hdma_spi3_tx.Init.Request = DMA_REQUEST_SPI3_TX;
                hdma_spi3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
                hdma_spi3_tx.Init.PeriphInc = DMA_PINC_DISABLE;
                hdma_spi3_tx.Init.MemInc = DMA_MINC_ENABLE;
                hdma_spi3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
                hdma_spi3_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
                hdma_spi3_tx.Init.Mode = DMA_NORMAL;
                hdma_spi3_tx.Init.Priority = DMA_PRIORITY_HIGH;
                hdma_spi3_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;

                HAL_DMA_Init(&hdma_spi3_tx)  ;    

                //__HAL_LINKDMA(hspi3,hdmatx,hdma_spi3_tx);
                               hspi3->hdmatx = &hdma_spi3_tx;  
                               hdma_spi3_tx.Parent =  hspi3;       


-------

参数：hdma_spi3_rx
HAL_DMA_Init( *hdma)     //here for spi3
        
        uint32_t registerValue;
        uint32_t tickstart = HAL_GetTick();
        DMA_Base_Registers         *regs_dma;
        BDMA_Base_Registers        *regs_bdma; 

        if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)     // DMA1 or DMA2 instance  （uart5, spi3）
        
                hdma->State = HAL_DMA_STATE_BUSY;
                __HAL_UNLOCK(hdma);
                __HAL_DMA_DISABLE(hdma);

                while((( hdma->Instance)->CR & DMA_SxCR_EN) != 0U)      //看是否成功disable
                                return HAL_DMA_ERROR_TIMEOUT;

                //----- 读取和设DMA的CR寄存器 -----

                registerValue = (hdma->Instance)->CR;

                //清0下面各位
                registerValue &= ~( DMA_SxCR_MBURST |    //memory 传输增量  --待理解
                                                     DMA_SxCR_PBURST |     //外设 传输增量  --待理解
                                                     DMA_SxCR_PL  |             //优先级
                                                     DMA_SxCR_MSIZE  |      //memory datasize
                                                     DMA_SxCR_PSIZE  |       //外设 datasize
                                                     DMA_SxCR_MINC  |       //memory 地址跟随模式   
                                                     DMA_SxCR_PINC   |        //外设 地址跟随模式
                                                     DMA_SxCR_CIRC   |         //圆形模式
                                                     DMA_SxCR_DIR   |          //数据传输方向
                                                     DMA_SxCR_CT     |         //当前内存是指向memory0还是memory1 （双缓冲模式下）
                                                     DMA_SxCR_DBM);         //是否双缓冲

                 registerValue |=   hdma->Init.Direction  |         //DMA_MEMORY_TO_PERIPH ， //  DMA_SxCR, 数据传输方向 MEMORY_TO_PERIPH
                                               hdma->Init.PeriphInc  |        //DMA_PINC_DISABLE                   // DMA_SxCR, 外设为固定地址
                                               hdma->Init.MemInc  |           //DMA_MINC_ENABLE                  // DMA_SxCR, memory 为地址跟随增加
                                               hdma->Init.PeriphDataAlignment |    //DMA_PDATAALIGN_BYTE;     // DMA_SxCR, PSIZE=0，外设 8BIT
                                               hdma->Init.MemDataAlignment |      //DMA_MDATAALIGN_BYTE      // DMA_SxCR, MSIZE=0，  memory 8BIT
                                               hdma->Init.Mode  |                              //DMA_DMA_NORMAL              // DMA_SxCR, 0, 非圆形模式
                                               hdma->Init.Priority;                              //DMA_DMA_PRIORITY_LOW   // DMA_SxCR, 优先级为低

                /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
                if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)    //TX和RX, 都为否
                       ......(忽略)

                /* Work around for Errata 2.22: UART/USART- DMA transfer lock: DMA stream could be
                       lock when transferring data to/from USART/UART */，待理解       
 
                        if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)          (这里是spi，固不满足uart的特定条件)             
                                registerValue |= DMA_SxCR_TRBUFF;                     //DMA_SxCR,，使能bufferable传输，待理解                      
 
                //写入DMA的CR寄存器
                (hdma->Instance)->CR = registerValue;


                 //-----读取和设置DMA的FCR寄存器-----

                registerValue = ( hdma->Instance)->FCR;
                registerValue &=~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);  //清零DMDIS,  FTH，或 为直接模式全速FIFO

                registerValue |= hdma->Init.FIFOMode;           //DMA_SxFCR，DMDIS=0, 不使能DMDIS

                if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)   //如果DMDIS=1,则下面  -- 待理解 （不满足条件，可忽略）                
                        ...... (忽略)                                          

                //写入DMA的FCR寄存器
                ( hdma->Instance)->FCR = registerValue;

                //------设置LIFCR-----

                regs_dma =  DMA_CalcBaseAndBitshift(hdma);   //或0--LISR

                //清LIFCR中的streaming3的所有中断标志
                regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU); //= 0x3f<<22  （或22指向streaming3）

         
        else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */ 
              ...... (忽略)
   
        else    
              ...... (忽略)
    

        if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
              ...... (忽略)
   
        hdma->ErrorCode = HAL_DMA_ERROR_NONE; 
        hdma->State = HAL_DMA_STATE_READY;
 
 
---

typedef struct
{
  __IO uint32_t ISR;    //中断状态标志
  __IO uint32_t Reserved0;
  __IO uint32_t IFCR;  //清中断标志
} DMA_Base_Registers;


参数 hdma_spi3_rx  （Instance = DMA2_Stream2）  
DMA_CalcBaseAndBitshift(  *hdma)
 
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
     
        stream_number = (( ( hdma->Instance) & 0xFFU) - 16U) / 24U;  //（0x40-16)/24=3   //表示DMA2_streaming2 

        static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
        hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U]; //=flagBitshiftOffset[2] = 16  //待验证

        if (stream_number > 3U)
            hdma->StreamBaseAddress = (  hdma->Instance  &  (~0x3FFU) ) + 4U ;    // return pointer to HISR and HIFCR 
         
        else
            hdma->StreamBaseAddress = (  hdma->Instance  &  (~0x3FFU));  //=0x40 & 0xfc00=0 , 返回指向 LISR and LIFCR    
         
    return hdma->StreamBaseAddress;
 
-----------


参数： hspi3     
SPI_GetPacketSize(  *hspi)   //待理解
 
      //fifo_threashold = (hspi->Init.FifoThreshold >> SPI_CFG1_FTHLV_Pos) + 1UL;
             fifo_threashold = (0 >>5) + 1 =1;

      //data_size       = (hspi->Init.DataSize      >> SPI_CFG1_DSIZE_Pos) + 1UL;
             data_size       = (7   >> 0) + 1 =8;
 
     data_size = (8 + 7 ) / 8;  //向上取整

     iret = data_size * fifo_threashold;  //8
 

 

=====================================spi通过发送数据=====普通方式和dma方式================================ 


 flow： (spi初始化)

             BoardInit -- MX_SPI3_Init -- HAL_SPI_Init --  HAL_SPI_MspInit  --  HAL_DMA_Init   -- __HAL_LINKDMA --  ?   ( IRQ)
 

 flow： (spi的发送数据, 有普通方式和dma方式两种)

         init  --  x  --  write_to_spi  -- spi3->write -- writetospi_  --   (DMA/normal)

------------------------------------------------------
 

 write_to_spi(  headerLength,   *headerBuffer,   bodyLength,   *bodyBuffer)
 
         struct spi_s   *spi = hal_uwb.uwbs->spi;  //spi3

         //spi->write(spi->handler, headerLength, headerBuffer, bodyLength, bodyBuffer);
         //     spi3->write(spi_handler3, headerLength, headerBuffer, bodyLength, bodyBuffer);
                       writetospi_(spi_handler3, headerLength, headerBuffer, bodyLength, bodyBuffer);
 

------

//初始化uwbs，唤醒dw3000
 init( )
 
    hal_uwb.uwbs = &uwbs;
    hal_uwb.uwbs->dw = &local_hal_dw;

    //hal_uwb.uwbs->spi = hal_uwb_init_spi(hal_uwb.uwbs->spi_io_cfg);   //spi3
    //     hal_uwb.uwbs->spi = hal_uwb_init_spi(  .idx = 3 );
              //spi =  init_spi(spi_port_cfg);
                    spi = spi3;
               spi->slow_rate(spi->handler);
     
    
    //hal_uwb.wakeup_with_io();
    //    hal_uwb_wakeup_with_io();
    //           hal_uwb.wakeup_fast();
                        hal_uwb_wakeup_fast(),   //通过cs唤醒dw3000

  
-----------

参数： spi_handler3
 writetospi_(  *handler,   headerLength,   *headerBuffer,   bodyLength,  *bodyBuffer)
 
                spi_handle_t *spi_handler = handler;
 
                kk1 = spi_handler3->phspi->Instance;      //=SPI3
                if( kk1  != SPI3 )                                              //都是SPI3, 条件不成立
                           error_handler(1, _ERR_SPI_DMA);
  
                while(spi_handler->Lock == HAL_LOCKED);
                __HAL_LOCK(spi_handler);            

                HAL_GPIO_WritePin(spi_handler->csPort, spi_handler->csPin, GPIO_PIN_RESET);     //拉低CS

                if (headerLength + bodyLength < SPI_DMA_MIN)    //32

                                HAL_SPI_Transmit( SPI3, headerBuffer, headerLength, 10);                /* Send header in polling mode */

                                if (bodyLength > 0)                                
                                           HAL_SPI_Transmit( SPI3,  bodyBuffer, bodyLength, 10);            /* Send data in polling mode */
                                 
                else                
                                
                                HAL_SPI_Transmit( SPI3,  headerBuffer, headerLength, 10);              /* Send header in polling mode */

                                if (bodyLength > 0)
                                
                                                spi_handler->TxComplete = TXRX_BLOCK_START;
                                                __DSB();
                                                __ISB();
                                                
                                                HAL_SPI_Transmit_DMA(SPI3,  bodyBuffer, bodyLength);      /* Send body in polling mode */
                                                while (spi_handler->TxComplete != TXRX_COMPLETE);
                                
                
                HAL_GPIO_WritePin(spi_handler->csPort, spi_handler->csPin, GPIO_PIN_SET);  //拉高CS
                __HAL_UNLOCK(spi_handler);


----------

HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE_2LINES_TXONLY(hspi->Init.Direction));

  /* Lock the process */
  __HAL_LOCK(hspi);

  if (hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
    __HAL_UNLOCK(hspi);
    return errorcode;
  }

  if ((pData == NULL) || (Size == 0UL))
  {
    errorcode = HAL_ERROR;
    __HAL_UNLOCK(hspi);
    return errorcode;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;

  /* Init field not used in handle to zero */
  hspi->pRxBuffPtr  = NULL;
  hspi->TxISR       = NULL;
  hspi->RxISR       = NULL;
  hspi->RxXferSize  = (uint16_t)0UL;
  hspi->RxXferCount = (uint16_t)0UL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
  }

  /* Packing mode management is enabled by the DMA settings */
  if (((hspi->Init.DataSize > SPI_DATASIZE_16BIT) && (hspi->hdmatx->Init.MemDataAlignment != DMA_MDATAALIGN_WORD))    || \
      ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) && ((hspi->hdmatx->Init.MemDataAlignment != DMA_MDATAALIGN_HALFWORD) && \
                                                     (hspi->hdmatx->Init.MemDataAlignment != DMA_MDATAALIGN_WORD))))
  {
    /* Restriction the DMA data received is not allowed in this mode */
    errorcode = HAL_ERROR;
    __HAL_UNLOCK(hspi);
    return errorcode;
  }

  /* Adjust XferCount according to DMA alignment / Data size */
  if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
  {
    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    {
      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 1UL) >> 1UL;
    }
    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_WORD)
    {
      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 3UL) >> 2UL;
    }
  }
  else if (hspi->Init.DataSize <= SPI_DATASIZE_16BIT)
  {
    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_WORD)
    {
      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 1UL) >> 1UL;
    }
  }
  else
  {
    /* Adjustment done */
  }

  /* Set the SPI TxDMA Half transfer complete callback */
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;

  /* Set the SPI TxDMA transfer complete callback */
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;

  /* Set the DMA error callback */
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;

  /* Set the DMA AbortCpltCallback */
  hspi->hdmatx->XferAbortCallback = NULL;

  /* Clear TXDMAEN bit*/
  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN);

  /* Enable the Tx DMA Stream/Channel */
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->TXDR,
                                 hspi->TxXferCount))
  {
    /* Update SPI error code */
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);

    /* Unlock the process */
    __HAL_UNLOCK(hspi);

    hspi->State = HAL_SPI_STATE_READY;
    errorcode = HAL_ERROR;
    return errorcode;
  }

  /* Set the number of data at current transfer */
  if (hspi->hdmatx->Init.Mode == DMA_CIRCULAR)
  {
    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, 0UL);
  }
  else
  {
    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);
  }

  /* Enable Tx DMA Request */
  SET_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN);

  /* Enable the SPI Error Interrupt Bit */
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_UDR | SPI_IT_FRE | SPI_IT_MODF));

  /* Enable SPI peripheral */
  __HAL_SPI_ENABLE(hspi);

  if (hspi->Init.Mode == SPI_MODE_MASTER)
  {
    /* Master transfer start */
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);
  }

  /* Unlock the process */
  __HAL_UNLOCK(hspi);
  return errorcode;
}

------


--//数据流： 使用 
--//参数： 
 HAL_DMA_Start_IT( *hdma,   SrcAddress,   DstAddress,   DataLength)
  
    __HAL_LOCK(hdma);

    if(HAL_DMA_STATE_READY == hdma->State)
 
        hdma->State = HAL_DMA_STATE_BUSY;
        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
        __HAL_DMA_DISABLE(hdma);

        /* Configure the source, destination address and the data length */
        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);    //使用hi2s->pTxBuffPtr  

        if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
        
            //使能常用的中断
            MODIFY_REG(( hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));

            if(hdma->XferHalfCpltCallback != NULL)
                /* Enable Half Transfer IT if corresponding Callback is set */
                (hdma->Instance)->CR    |= DMA_IT_HT;

        
        else   /* BDMA channel */
        
           （忽略） 


        if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
        
            /* Check if DMAMUX Synchronization is enabled */
            if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
            
                /* Enable DMAMUX sync overrun IT*/
                hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
            
            if(hdma->DMAmuxRequestGen != 0U)
            
                /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
                /* enable the request gen overrun IT */
                hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;                   

        /* Enable the Peripheral */
        __HAL_DMA_ENABLE(hdma);



=============================================spi接收数据===================================== 


 flow： (spi初始化)

             BoardInit -- MX_SPI3_Init -- HAL_SPI_Init --  HAL_SPI_MspInit  --  HAL_DMA_Init   -- __HAL_LINKDMA --  ?   ( IRQ)
 

 flow： (spi的发送数据, 有普通方式和dma方式两种)

         init  --  x  --  read_from_spi  -- spi3->read -- readfromspi_  --   


----------------------


 read_from_spi(  headerLength,   *headerBuffer,   readlength,  *readBuffer)
 
    struct spi_s *spi = hal_uwb.uwbs->spi;
    return spi->read(spi->handler, headerLength, headerBuffer, readlength, readBuffer);
 

 