
接收过程： 

    (从机地址已匹配 + W标志 + 清地址匹配标志 + ack)   --  { TXIS + data0 }  -- (RXNE + 从机读数据+ Ack)   ...... {TXIS + datan} -- (RXNE + 从机读数据+ Ack) -- Stop标志 --两边清stop标志 



========================i2c slave  init================================

main

   MX_GPIO_Init();
   MX_I2C1_Init();

------------------------



 MX_GPIO_Init( )
 
     LL_EXTI_InitTypeDef       EXTI_InitStruct = {0};
     LL_GPIO_InitTypeDef     GPIO_InitStruct = {0};

     //使能GPIO时钟
     LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOC);   //使能PORTC时钟
     LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);   //使能PORTA时钟
     LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOB);   //使能PORTB时钟

     LL_GPIO_ResetOutputPin(LED4_GPIO_Port, LED4_Pin);     // LED4 为低电平  //PB6

     LL_EXTI_SetEXTISource(LL_EXTI_CONFIG_PORTC, LL_EXTI_CONFIG_LINE13);   //设置PC13为外部中断

     //外部中断初始化
     EXTI_InitStruct.Line_0_31 = LL_EXTI_LINE_13;
     EXTI_InitStruct.LineCommand = ENABLE;
     EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
     EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_FALLING;   //下降沿触发
     LL_EXTI_Init(&EXTI_InitStruct);

     //设置PC13内部上拉
     LL_GPIO_SetPinPull(USER_BUTTON_GPIO_Port, USER_BUTTON_Pin, LL_GPIO_PULL_UP);

     //设置PC13为输入
     LL_GPIO_SetPinMode(USER_BUTTON_GPIO_Port, USER_BUTTON_Pin, LL_GPIO_MODE_INPUT);

     //设置PB6为推拉输出
     GPIO_InitStruct.Pin = LED4_Pin;
     GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
     GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
     LL_GPIO_Init(LED4_GPIO_Port, &GPIO_InitStruct);

     //设置外部中断的优先级
     //NVIC_SetPriority(EXTI4_15_IRQn, 0);
           __NVIC_SetPriority(7, 0);

     //使能外部中断
     NVIC_EnableIRQ(EXTI4_15_IRQn);

 
------


 MX_I2C1_Init()

     LL_I2C_InitTypeDef I2C_InitStruct = {0};
     LL_GPIO_InitTypeDef GPIO_InitStruct = {0};

     //设置I2C时钟源
     LL_RCC_SetI2CClockSource(LL_RCC_I2C1_CLKSOURCE_PCLK1);

      //使能PORTB时钟
     LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOB);
    
     //初始化SCL端口
     GPIO_InitStruct.Pin = LL_GPIO_PIN_8;                                           //SCL
     GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
     GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
     GPIO_InitStruct.Alternate = LL_GPIO_AF_6;
     LL_GPIO_Init(GPIOB, &GPIO_InitStruct);

     //初始化SDA端口
     GPIO_InitStruct.Pin = LL_GPIO_PIN_9;                                          //SDA
     GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
     GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
     GPIO_InitStruct.Alternate = LL_GPIO_AF_6;
     LL_GPIO_Init(GPIOB, &GPIO_InitStruct);

     //使能 i2c时钟    
     LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_I2C1);        

     //初始化I2C
     I2C_InitStruct.PeripheralMode = LL_I2C_MODE_I2C;
     I2C_InitStruct.Timing = 0x0090273D;
     I2C_InitStruct.AnalogFilter = LL_I2C_ANALOGFILTER_ENABLE;
     I2C_InitStruct.DigitalFilter = 2;
     I2C_InitStruct.OwnAddress1 = 180;
     I2C_InitStruct.TypeAcknowledge = LL_I2C_ACK;
     I2C_InitStruct.OwnAddrSize = LL_I2C_OWNADDRESS1_7BIT;
     LL_I2C_Init(I2C1, &I2C_InitStruct);

     //待理解
     LL_I2C_EnableAutoEndMode(I2C1);
     LL_I2C_SetOwnAddress2(I2C1, 0, LL_I2C_OWNADDRESS2_NOMASK);
     LL_I2C_DisableOwnAddress2(I2C1);
     LL_I2C_DisableGeneralCall(I2C1);
     LL_I2C_EnableClockStretching(I2C1);
    
     //关闭I2C
     LL_I2C_Disable(I2C1);

      /* Configure the SDA setup, hold time and the SCL high, low period */
      /* Timing register value is computed with the STM32CubeMX Tool,
        * Fast Mode @400kHz with I2CCLK = 48 MHz,
        * rise time = 100ns, fall time = 10ns
        * Timing Value = (uint32_t)0x0090273D
        */
      LL_I2C_SetTiming(I2C1, I2C_TIMING);


      //设置从机地址
      //LL_I2C_SetOwnAddress1(I2C1, SLAVE_OWN_ADDRESS, LL_I2C_OWNADDRESS1_7BIT);
      //    LL_I2C_SetOwnAddress1(I2C1, 180, 0);
      //        MODIFY_REG(I2Cx->OAR1, I2C_OAR1_OA1 | I2C_OAR1_OA1MODE, OwnAddress1 | OwnAddrSize);
                  MODIFY_REG(I2Cx->OAR1, 0x3ff | 1<<10, 180 | 0);  //OAR1.0-10=0, OAR1.7-1=180 ,设置从机地址为 180，忽略bit0,8,9  (实际是180/2放在bit1-7)


      //使能从机地址
      LL_I2C_EnableOwnAddress1(I2C1);
             SET_BIT(I2Cx->OAR1, I2C_OAR1_OA1EN);  //OAR1.15=1  //待理解  （或见到匹配从机地址，返回ACK信号）

     //开启I2C
     LL_I2C_Enable(I2C1); 




========================i2c  slave  receive================================


main



while(1)

      Handle_I2C_Slave();


-------------


接收过程： 

    (从机地址已匹配 + W标志 + 清地址匹配标志 + ack)   --  { TXIS + data0 }  -- (RXNE + 从机读数据+ Ack)   ...... {TXIS + datan} -- (RXNE + 从机读数据+ Ack) -- Stop标志 --两边清stop标志 


Handle_I2C_Slave( )
 
      //等待有匹配地址進来
      while (!LL_I2C_IsActiveFlag_ADDR(I2C1)) ；
 

      //检查地址是否跟本地addr相同
      if (LL_I2C_GetAddressMatchCode(I2C1) == SLAVE_OWN_ADDRESS)
 
            if (LL_I2C_GetTransferDirection(I2C1) == LL_I2C_DIRECTION_WRITE)    //如果ISR.16=0（主机写数据）, 则如下写入处理     

                   //LL_I2C_ClearFlag_ADDR(I2C1);    
                          SET_BIT(I2Cx->ICR, I2C_ICR_ADDRCF);   //ICR.3=1, 请地址匹配标志 （应会返回Ack ，待验证）
    
            else  //如ISR.16=1,则为读取，这里不做处理
 
                  LL_I2C_ClearFlag_ADDR(I2C1);   //ICR.3=1, 请地址匹配标志 （应返回Ack ，待验证）
                  Error_Callback();   

      else
            LL_I2C_ClearFlag_ADDR(I2C1);
            Error_Callback();
 

      //接收数据，直到遇到停止位
      while (!LL_I2C_IsActiveFlag_STOP(I2C1))
      
            if (LL_I2C_IsActiveFlag_RXNE(I2C1))   //如RXNE=1，则读取数据

                  //aReceiveBuffer[ubReceiveIndex++] = LL_I2C_ReceiveData8(I2C1); 
                        aReceiveBuffer[ubReceiveIndex++] = READ_BIT(I2Cx->RXDR, I2C_RXDR_RXDATA)；  //=RXDR & 0xff , 从机读取一个字节的数据  （应返回Ack ，待验证）


      //清楚stop标志
      LL_I2C_ClearFlag_STOP(I2C1);

      //判断数据是否正确
      if (Buffercmp8( aReceiveBuffer,  aLedOn, (ubReceiveIndex - 1)) == 0) 

            LED_On();     
      else   
            Error_Callback();
 

------

LL_I2C_IsActiveFlag_ADDR( *I2Cx) 
      return (  ( READ_BIT(I2Cx->ISR, I2C_ISR_ADDR) == (I2C_ISR_ADDR) ) ? 1  : 0   );
 
---

__STATIC_INLINE uint32_t LL_I2C_GetAddressMatchCode(const I2C_TypeDef *I2Cx) 
      return (uint32_t)(READ_BIT(I2Cx->ISR, I2C_ISR_ADDCODE) >> I2C_ISR_ADDCODE_Pos << 1);
 
---

__STATIC_INLINE uint32_t LL_I2C_GetTransferDirection(const I2C_TypeDef *I2Cx)
 
      return (uint32_t)(READ_BIT(I2Cx->ISR, I2C_ISR_DIR));
 


========================i2c  slave  write================================

从机发送数据：

 { SLA + 7Bit + 设发送长度len + autoend + Start + R }  --   (从机地址已匹配 + R标志 + 清地址匹配标志 + ack)  + (TXIS + data1  ) -- { RXNE + ack } 
  ......  + (TXIS + datan  )  -- { RXNE + /ack + stop}


main



while(1)

      Handle_I2C_Slave();


-------------


Handle_I2C_Slave_Write( )
 
      while (!LL_I2C_IsActiveFlag_ADDR(I2C1)) ；
 

      if (LL_I2C_GetAddressMatchCode(I2C1) == SLAVE_OWN_ADDRESS)
     
            if (LL_I2C_GetTransferDirection(I2C1) == LL_I2C_DIRECTION_WRITE)
         
                  LL_I2C_ClearFlag_ADDR(I2C1);
          
            else      //Read

                  LL_I2C_ClearFlag_ADDR(I2C1); 
                                                      
//--my slave chg 1                                                      
                   //LL_I2C_TransmitData8(I2C1, SLAVE_BYTE_TO_SEND);


      while (!LL_I2C_IsActiveFlag_STOP(I2C1))

            if (LL_I2C_IsActiveFlag_RXNE(I2C1))
                  aReceiveBuffer[ubReceiveIndex++] = LL_I2C_ReceiveData8(I2C1);
                                    
//--my slave chg 2                                                      
 
           if (LL_I2C_IsActiveFlag_TXIS(I2C1))
 
                  /* Write data in Transmit Data register.
                  TXIS flag is cleared by writing data in TXDR register */
                  LL_I2C_TransmitData8(I2C1, (*pTransmitBuffer++));
          
      /* End of I2C_SlaveReceiver_MasterTransmitter_DMA Process */
      LL_I2C_ClearFlag_STOP(I2C1);

////iputs1("readed ");     









