

========================i2c master  init================================


main

     //MX_GPIO_Init();
            __HAL_RCC_GPIOB_CLK_ENABLE();


     MX_I2C1_Init();

     BSP_LED_Init(LED4);
     BSP_PB_Init(BUTTON_USER, BUTTON_MODE_GPIO);

    

--------------------


 MX_I2C1_Init( )
 
      hi2c1.Instance = I2C1;
      hi2c1.Init.Timing = 0x0030081C;
      hi2c1.Init.OwnAddress1 = I2C_ADDRESS;                                    //从机地址
      hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;       //7位地址模式
      hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
      hi2c1.Init.OwnAddress2 = 0;
      hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;                    //待理解
      hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;           //待理解
      hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;                //待理解

      HAL_I2C_Init(&hi2c1) ；

      HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE);

      HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0)；

      // I2C Fast mode Plus enable   
      HAL_I2CEx_EnableFastModePlus(I2C_FASTMODEPLUS_I2C1);
 

-------------

 HAL_I2C_Init(  *hi2c)
 
      if (hi2c->State == HAL_I2C_STATE_RESET)
            hi2c->Lock = HAL_UNLOCKED; 
            HAL_I2C_MspInit(hi2c); 

      hi2c->State = HAL_I2C_STATE_BUSY;
 
      __HAL_I2C_DISABLE(hi2c);
 
      hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK; 
      hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 
      if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)   
            hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);     
      else      
            hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);    
 
      hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
      hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
      hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 |  (hi2c->Init.OwnAddress2Masks << 8));
      hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);

      __HAL_I2C_ENABLE(hi2c);    //开启i2c

      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
      hi2c->State = HAL_I2C_STATE_READY;
      hi2c->PreviousState = I2C_STATE_NONE;
      hi2c->Mode = HAL_I2C_MODE_NONE;

  
----------------

HAL_I2C_MspInit(  i2cHandle)
{

      GPIO_InitTypeDef GPIO_InitStruct = {0};
      RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

      if(i2cHandle->Instance==I2C1)
 
            PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
            PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;

            HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) ； 

            __HAL_RCC_GPIOB_CLK_ENABLE();
 
            GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;    //i2c  引脚初始化
            GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
            GPIO_InitStruct.Pull = GPIO_PULLUP;
            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
            GPIO_InitStruct.Alternate = GPIO_AF6_I2C1;
            HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

 
            __HAL_RCC_I2C1_CLK_ENABLE();
 
            HAL_NVIC_SetPriority(I2C1_IRQn, 0, 0);
            HAL_NVIC_EnableIRQ(I2C1_IRQn);




========================i2c master  write================================


main

       //等待按键按下
       while (BSP_PB_GetState(BUTTON_USER) != GPIO_PIN_RESET)；    

       //等待按键弹起
       while (BSP_PB_GetState(BUTTON_USER) != GPIO_PIN_SET)；


     while(1)

            hTxNumData = TXBUFFERSIZE;
            hRxNumData = RXBUFFERSIZE;
 
            bTransferRequest = MASTER_REQ_WRITE;


/*##--2 - Master sends write request for slave   //主机发送发数据请求

            HAL_I2C_Master_Transmit_IT(&hi2c1,  I2C_ADDRESS,  &bTransferRequest, 1)；

            while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY)；



/*##-3- Master sends number of data to be written   //主机发数据长度    （待理解）     //是否多余的步骤--可由autoend决定

           HAL_I2C_Master_Transmit_IT(&hi2c1,  I2C_ADDRESS,  &hTxNumData, 2);

           while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY);


/*##-4- Master sends aTxBuffer to slave    //主机发数据给从机

            HAL_I2C_Master_Transmit_IT(&hi2c1, I2C_ADDRESS,  aTxBuffer, TXBUFFERSIZE)；

            while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY);



---------------------------------------

参数： &hi2c1,  3E,  buf,  len
HAL_I2C_Master_Transmit_IT( *hi2c,  DevAddress,  pData, Size)
 
      uint32_t xfermode;

      if (hi2c->State == HAL_I2C_STATE_READY)
 
            __HAL_LOCK(hi2c);

            hi2c->State                   = HAL_I2C_STATE_BUSY_TX;
            hi2c->Mode                  = HAL_I2C_MODE_MASTER;
            hi2c->ErrorCode       = HAL_I2C_ERROR_NONE;

            hi2c->pBuffPtr            = pData;
            hi2c->XferCount       = Size;
            hi2c->XferOptions = I2C_NO_OPTION_FRAME;
            hi2c->XferISR             = I2C_Master_ISR_IT;
 
            hi2c->XferSize = hi2c->XferCount;
            xfermode = I2C_AUTOEND_MODE; 

 
            if (hi2c->XferSize > 0)
 
                  hi2c->Instance->TXDR = *hi2c->pBuffPtr;

                  hi2c->pBuffPtr++;

                  hi2c->XferCount--;
                  hi2c->XferSize--;

                  I2C_TransferConfig(hi2c, DevAddress,  (hi2c->XferSize + 1), xfermode,   I2C_GENERATE_START_WRITE);
           
            else           
                  I2C_TransferConfig(hi2c, DevAddress,  hi2c->XferSize, xfermode,   I2C_GENERATE_START_WRITE);
 
            __HAL_UNLOCK(hi2c);
 
            I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
 

---------------------------

参数： hi2c, DevAddress, 6+1, autoend,   1<<13 | 0<<10 （Start + W） 
 I2C_TransferConfig( *hi2c,  DevAddress,   Size,  Mode,    Request)
 
      tmp = (  (( DevAddress & I2C_CR2_SADD) |   (( Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) |  Mode |  Request)
                 & (~0x80000000) );

      /* update CR2 register */
      MODIFY_REG(hi2c->Instance->CR2,  
                                     ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND |  
                                     (I2C_CR2_RD_WRN &  (Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP))
                                     ,  tmp);
 

========================i2c master  read================================


main

       //等待按键按下
       while (BSP_PB_GetState(BUTTON_USER) != GPIO_PIN_RESET)；    

       //等待按键弹起
       while (BSP_PB_GetState(BUTTON_USER) != GPIO_PIN_SET)；


     while(1)

            hTxNumData = TXBUFFERSIZE;
            hRxNumData = RXBUFFERSIZE;
 
            bTransferRequest = MASTER_REQ_WRITE;


/*##-5- Master sends read request for slave 

            HAL_I2C_Master_Transmit_IT(&hi2c1, I2C_ADDRESS,  &bTransferRequest, 1)；

            while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY)；



/*##-6- Master sends number of data to be read    

           HAL_I2C_Master_Transmit_IT(&hi2c1,  I2C_ADDRESS,  &hRxNumData, 2);

           while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY);


/*##-7- Master receives aRxBuffer from slave

            HAL_I2C_Master_Receive_IT(&hi2c1,  I2C_ADDRESS,  aRxBuffer, RXBUFFERSIZE)；

            while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY);

 
            //比较数据
            if (Buffercmp( aTxBuffer,  aRxBuffer, hRxNumData)) 
                  Error_Handler();    //err，小灯慢闪
   
            Flush_Buffer(aRxBuffer, RXBUFFERSIZE);
 
            BSP_LED_Toggle(LED4);
           HAL_Delay(25);


------


参数： &hi2c1,  3E,  aRxBuffer,  len
 HAL_I2C_Master_Receive_IT( *hi2c,  DevAddress,   *pData, Size)
   
            hi2c->State                   = HAL_I2C_STATE_BUSY_RX;
            hi2c->Mode                        = HAL_I2C_MODE_MASTER;
            hi2c->ErrorCode       = HAL_I2C_ERROR_NONE;

            hi2c->pBuffPtr            = pData;
            hi2c->XferCount       = Size;
            hi2c->XferOptions = I2C_NO_OPTION_FRAME;
            hi2c->XferISR             = I2C_Master_ISR_IT;
 
            hi2c->XferSize = hi2c->XferCount;
             xfermode = I2C_AUTOEND_MODE;
   
 
            I2C_TransferConfig(hi2c, DevAddress,  hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
 
            __HAL_UNLOCK(hi2c);
 
            I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);

 
------------

参数： hi2c, DevAddress, 6+1, autoend,  1<<13 | 1<<10 （Start + R） 
 I2C_TransferConfig( *hi2c,  DevAddress,   Size,  Mode,    Request)
 
      tmp = (  (( DevAddress & I2C_CR2_SADD) |   (( Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) |  Mode |  Request)
                 & (~0x80000000) );

      /* update CR2 register */
      MODIFY_REG(hi2c->Instance->CR2,  
                                     ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND |  
                                     (I2C_CR2_RD_WRN &  (Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP))
                                     ,  tmp);
 

----------------------




=============================待处理==================================


  I2C_Master_ISR_IT(  *hi2c,  ITFlags,  ITSources)
{
      uint16_t devaddress;
      uint32_t tmpITFlags = ITFlags;

      /* Process Locked */
      __HAL_LOCK(hi2c);

      if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
                  (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
      {
            /* Clear NACK Flag */
            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

            /* Set corresponding Error Code */
            /* No need to generate STOP, it is automatically done */
            /* Error callback will be send during stop flag treatment */
            hi2c->ErrorCode |= HAL_I2C_ERROR_AF;

            /* Flush TX register */
            I2C_Flush_TXDR(hi2c);
      }
      else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
                               (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
      {
            /* Remove RXNE flag on temporary variable as read done */
            tmpITFlags &= ~I2C_FLAG_RXNE;

            /* Read data from RXDR */
            *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;

            /* Increment Buffer pointer */
            hi2c->pBuffPtr++;

            hi2c->XferSize--;
            hi2c->XferCount--;
      }
      else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) == RESET) && \
                               ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
                                    (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET)))
      {
            /* Write data to TXDR */
            if (hi2c->XferCount != 0U)
            {
                  /* Write data to TXDR */
                  hi2c->Instance->TXDR = *hi2c->pBuffPtr;

                  /* Increment Buffer pointer */
                  hi2c->pBuffPtr++;

                  hi2c->XferSize--;
                  hi2c->XferCount--;
            }
      }
      else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \
                               (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
      {
            if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
            {
                  devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);

                  if (hi2c->XferCount > MAX_NBYTE_SIZE)
                  {
                        hi2c->XferSize = MAX_NBYTE_SIZE;
                        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
                  }
                  else
                  {
                        hi2c->XferSize = hi2c->XferCount;
                        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
                        {
                              I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
                                                                                     hi2c->XferOptions, I2C_NO_STARTSTOP);
                        }
                        else
                        {
                              I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
                                                                                     I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
                        }
                  }
            }
            else
            {
                  /* Call TxCpltCallback() if no stop mode is set */
                  if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
                  {
                        /* Call I2C Master Sequential complete process */
                        I2C_ITMasterSeqCplt(hi2c);
                  }
                  else
                  {
                        /* Wrong size Status regarding TCR flag event */
                        /* Call the corresponding callback to inform upper layer of End of Transfer */
                        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
                  }
            }
      }
      else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \
                               (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
      {
            if (hi2c->XferCount == 0U)
            {
                  if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
                  {
                        /* Generate a stop condition in case of no transfer option */
                        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
                        {
                              /* Generate Stop */
                              hi2c->Instance->CR2 |= I2C_CR2_STOP;
                        }
                        else
                        {
                              /* Call I2C Master Sequential complete process */
                              I2C_ITMasterSeqCplt(hi2c);
                        }
                  }
            }
            else
            {
                  /* Wrong size Status regarding TC flag event */
                  /* Call the corresponding callback to inform upper layer of End of Transfer */
                  I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
            }
      }
      else
      {
            /* Nothing to do */
      }

      if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
                  (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
      {
            /* Call I2C Master complete process */
            I2C_ITMasterCplt(hi2c, tmpITFlags);
      }

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);

      return HAL_OK;
}









